<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI æˆ€æ„›è‚²æˆéŠæˆ²</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts: Noto Sans TC for Traditional Chinese -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Custom styles for background and font */
    body {
      font-family: 'Noto Sans TC', sans-serif;
      background: url('https://images.unsplash.com/photo-1503264116251-35a269479413?auto=format&fit=crop&w=1950&q=80') no-repeat center center fixed;
      background-size: cover;
      color: white;
    }
    /* Scrollbar styling for chatbox */
    #chat::-webkit-scrollbar {
      width: 8px;
    }
    #chat::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }
    #chat::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 10px;
    }
    #chat::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Modal styles */
    .modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
      backdrop-filter: blur(5px); /* Blur background */
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: rgba(255, 255, 255, 0.2);
      margin: auto;
      padding: 20px;
      border-radius: 1rem;
      border: 1px solid rgba(255, 255, 255, 0.3);
      width: 80%;
      max-width: 400px;
      text-align: center;
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }
    .close-button {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }
    .close-button:hover,
    .close-button:focus {
      color: white;
      text-decoration: none;
      cursor: pointer;
    }
  </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
  <div class="glass bg-white bg-opacity-10 rounded-2xl p-6 md:p-8 shadow-xl max-w-4xl w-full flex flex-col md:flex-row gap-6 border border-white border-opacity-30 backdrop-filter backdrop-blur-lg">
    <div class="md:w-1/2 flex flex-col items-center justify-center p-4">
      <h1 class="text-3xl md:text-4xl font-bold mb-4 text-center">AI æˆ€æ„›è‚²æˆéŠæˆ²</h1>
      <div class="relative w-48 h-48 md:w-64 md:h-64 rounded-full overflow-hidden border-4 border-pink-400 shadow-lg mb-4">
        <img id="characterImage" src="https://placehold.co/256x256/ffc0cb/ffffff?text=Yuki" alt="AI Character" class="w-full h-full object-cover">
        <div class="absolute inset-0 bg-gradient-to-t from-black via-transparent to-transparent opacity-50"></div>
      </div>
      <label for="characterSelect" class="text-lg mb-2">è§’è‰²é¸æ“‡ï¼š</label>
      <select id="characterSelect" class="w-full p-2 rounded-lg bg-white bg-opacity-20 text-white border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-pink-300 transition duration-200">
        <option value="yuki" class="bg-gray-800 text-white">é›ªå§¬ Yukiï¼ˆæº«æŸ”å…§å‘ï¼‰</option>
        <option value="kira" class="bg-gray-800 text-white">ç¶ºç¾… Kiraï¼ˆå‚²å¬Œå‹ï¼‰</option>
        <option value="sora" class="bg-gray-800 text-white">ç©º Soraï¼ˆå…ƒæ°£å°‘å¥³ï¼‰</option>
        <option value="reika" class="bg-gray-800 text-white">å†·è¯ Reikaï¼ˆé«˜å†·å­ä¸–ï¼‰</option>
        <option value="kuro" class="bg-gray-800 text-white">é»‘éŸ³ Kuroï¼ˆç—…å¬Œè®Šæ…‹ï¼‰</option>
      </select>
      <p class="text-lg mt-4 text-center">
        å¥½æ„Ÿåº¦ï¼š<span id="affection" class="font-bold text-pink-300">0</span> â¤ï½œ
        æˆé•·ç­‰ç´šï¼š<span id="level" class="font-bold text-yellow-300">1</span> âœ¨
      </p>
      <p class="text-sm mt-2 text-center text-gray-300">
        ç©å®¶ ID: <span id="playerUserId" class="font-mono text-gray-200 break-all">è¼‰å…¥ä¸­...</span>
      </p>
    </div>

    <div class="md:w-1/2 flex flex-col p-4">
      <div id="chat" class="flex-grow h-80 md:h-96 overflow-y-auto p-4 bg-black bg-opacity-20 rounded-lg mb-4 border border-white border-opacity-30 shadow-inner">
        <!-- Chat messages will be appended here -->
      </div>
      <div class="flex flex-col sm:flex-row gap-2 mb-4">
        <input type="text" id="userInput" placeholder="èªªäº›è©±..." class="flex-grow p-3 rounded-lg bg-white bg-opacity-20 text-white placeholder-gray-300 border border-white border-opacity-30 focus:outline-none focus:ring-2 focus:ring-blue-300 transition duration-200" />
        <button onclick="window.sendMessage()" id="sendButton" class="px-6 py-3 rounded-lg bg-gradient-to-r from-pink-500 to-red-500 text-white font-bold shadow-md hover:from-pink-600 hover:to-red-600 focus:outline-none focus:ring-2 focus:ring-pink-400 transition duration-200">
          ç™¼é€
        </button>
      </div>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
        <button onclick="window.saveGame()" class="px-6 py-3 rounded-lg bg-gradient-to-r from-purple-500 to-indigo-500 text-white font-bold shadow-md hover:from-purple-600 hover:to-indigo-600 focus:outline-none focus:ring-2 focus:ring-purple-400 transition duration-200">
          ğŸ’¾ å­˜æª”
        </button>
        <button onclick="window.loadGame()" class="px-6 py-3 rounded-lg bg-gradient-to-r from-green-500 to-teal-500 text-white font-bold shadow-md hover:from-green-600 hover:to-teal-600 focus:outline-none focus:ring-2 focus:ring-green-400 transition duration-200">
          ğŸ“‚ è¼‰å…¥å­˜æª”
        </button>
      </div>
      <div id="achievementBox" class="mt-6 p-4 bg-white bg-opacity-15 rounded-lg border border-white border-opacity-30 shadow-inner">
        <h3 class="text-xl font-semibold mb-2 text-center">ğŸ† æˆå°±</h3>
        <ul id="achievements" class="list-disc list-inside text-gray-200">
          <!-- Achievements will be added here -->
        </ul>
      </div>
    </div>
  </div>

  <!-- Loading Indicator -->
  <div id="loadingIndicator" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
    <div class="flex flex-col items-center">
      <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-pink-500"></div>
      <p class="mt-4 text-white text-lg">AI æ­£åœ¨æ€è€ƒä¸­...</p>
    </div>
  </div>

  <!-- Custom Modal for Alerts -->
  <div id="customModal" class="modal">
    <div class="modal-content">
      <span class="close-button" onclick="window.closeModal()">&times;</span>
      <p id="modalMessage" class="text-white text-lg"></p>
      <button onclick="window.closeModal()" class="mt-4 px-6 py-2 rounded-lg bg-blue-500 text-white font-bold hover:bg-blue-600 transition duration-200">ç¢ºèª</button>
    </div>
  </div>

  <!-- Firebase SDKs -->
  <script type="module">
    // Firebase imports for app, auth, and firestore
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, onSnapshot, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Global variables from the Canvas environment
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    // Initialize Firebase
    let app, db, auth;
    let currentUserId = null; // Will store the authenticated user's ID
    let unsubscribeChatListener = null; // To store the unsubscribe function for chat history listener

    // DOM Elements
    const chatBox = document.getElementById("chat");
    const affectionDisplay = document.getElementById("affection");
    const levelDisplay = document.getElementById("level");
    const charSelect = document.getElementById("characterSelect");
    const achievementsList = document.getElementById("achievements");
    const characterImage = document.getElementById("characterImage");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const playerUserIdDisplay = document.getElementById("playerUserId");
    const sendButton = document.getElementById("sendButton");
    const userInput = document.getElementById("userInput");

    // Game State Variables
    let affection = 0;
    let level = 1;
    let unlockedAchievements = [];
    // Detect user's browser language for AI response
    let language = navigator.language.startsWith('zh-TW') ? 'ç¹é«”ä¸­æ–‡' :
                   navigator.language.startsWith('zh') ? 'ç°¡é«”ä¸­æ–‡' :
                   navigator.language.startsWith('ja') ? 'æ—¥æœ¬èª' : 'English';

    // Character image map and full names for display
    const characterDetails = {
      yuki: { name: "é›ªå§¬ Yuki", image: "https://placehold.co/256x256/ffc0cb/ffffff?text=Yuki" },
      kira: { name: "ç¶ºç¾… Kira", image: "https://placehold.co/256x256/add8e6/ffffff?text=Kira" },
      sora: { name: "ç©º Sora", image: "https://placehold.co/256x256/90ee90/ffffff?text=Sora" },
      reika: { name: "å†·è¯ Reika", image: "https://placehold.co/256x256/d3d3d3/ffffff?text=Reika" },
      kuro: { name: "é»‘éŸ³ Kuro", image: "https://placehold.co/256x256/800080/ffffff?text=Kuro" }
    };

    // --- Modal Functions ---
    window.showModal = function(message) {
      document.getElementById('modalMessage').textContent = message;
      document.getElementById('customModal').style.display = 'flex';
    }

    window.closeModal = function() {
      document.getElementById('customModal').style.display = 'none';
    }

    // --- Achievement System ---
    const checkAchievements = () => {
      if (affection >= 50 && !unlockedAchievements.includes('æˆ€æ„›å•Ÿèˆª')) {
        unlockedAchievements.push('æˆ€æ„›å•Ÿèˆª');
        addAchievement('æˆ€æ„›å•Ÿèˆª');
        window.showModal('æ­å–œï¼è§£é–æˆå°±ï¼šæˆ€æ„›å•Ÿèˆªï¼');
      }
      if (affection >= 100 && !unlockedAchievements.includes('å¿ƒéˆé€£çµ')) {
        unlockedAchievements.push('å¿ƒéˆé€£çµ');
        addAchievement('å¿ƒéˆé€£çµ');
        window.showModal('æ­å–œï¼è§£é–æˆå°±ï¼šå¿ƒéˆé€£çµï¼');
      }
      if (charSelect.value === 'kuro' && affection >= 30 && !unlockedAchievements.includes('é»‘æš—ä¸­çš„å¾®ç¬‘')) {
        unlockedAchievements.push('é»‘æš—ä¸­çš„å¾®ç¬‘');
        addAchievement('é»‘æš—ä¸­çš„å¾®ç¬‘');
        window.showModal('æ­å–œï¼è§£é–æˆå°±ï¼šé»‘æš—ä¸­çš„å¾®ç¬‘ï¼');
      }
      if (level >= 5 && !unlockedAchievements.includes('æˆé•·çš„å–œæ‚…')) {
        unlockedAchievements.push('æˆé•·çš„å–œæ‚…');
        addAchievement('æˆé•·çš„å–œæ‚…');
        window.showModal('æ­å–œï¼è§£é–æˆå°±ï¼šæˆé•·çš„å–œæ‚…ï¼');
      }
      if (affection >= 200 && !unlockedAchievements.includes('æ°¸æ†çš„æ„›')) {
        unlockedAchievements.push('æ°¸æ†çš„æ„›');
        addAchievement('æ°¸æ†çš„æ„›');
        window.showModal('æ­å–œï¼è§£é–æˆå°±ï¼šæ°¸æ†çš„æ„›ï¼');
      }
    };

    const addAchievement = (title) => {
      const li = document.createElement("li");
      li.textContent = title;
      achievementsList.appendChild(li);
    };

    // --- Display Messages in Chat ---
    function displayMessage(msg, className, characterDisplayName = null) {
      const p = document.createElement("p");
      p.className = `message ${className} my-2 p-2 rounded-lg max-w-[80%]`;
      if (className === 'user') {
        p.classList.add('ml-auto', 'bg-blue-500', 'text-white');
        p.textContent = "ä½ ï¼š" + msg;
      } else {
        p.classList.add('mr-auto', 'bg-gray-700', 'text-white');
        p.textContent = (characterDisplayName ? characterDisplayName : "AI") + "ï¼šã€Œ" + msg + "ã€";
      }
      chatBox.appendChild(p);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // --- Game Logic ---
    async function sendMessage() { // Defined as a regular function within module scope
      const message = userInput.value.trim();
      if (!message || !currentUserId) {
        if (!currentUserId) {
          window.showModal("è«‹ç­‰å¾…éŠæˆ²åˆå§‹åŒ–ä¸¦ç™»å…¥å¾Œå†ç™¼é€è¨Šæ¯ã€‚");
        }
        return;
      }

      const characterId = charSelect.value;
      const characterDisplayName = characterDetails[characterId]?.name || characterId;

      displayMessage(message, "user");
      userInput.value = "";
      sendButton.disabled = true;
      userInput.disabled = true;
      loadingIndicator.classList.remove('hidden');

      // Update affection and level
      if (message.includes("å–œæ­¡") || message.includes("æƒ³ä½ ") || message.includes("å¯æ„›") || message.includes("love")) {
        affection += 5;
        if (affection % 20 === 0) level += 1;
      }
      affectionDisplay.textContent = affection;
      levelDisplay.textContent = level;
      checkAchievements();

      const date = new Date();
      const today = date.toISOString().split('T')[0];
      let dailyEvent = "";

      const dailyEventDocRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'dailyEvents', today);
      try {
        const snapshot = await getDoc(dailyEventDocRef);
        if (!snapshot.exists()) {
          dailyEvent = `ï¼ˆä»Šæ—¥é™å®šäº‹ä»¶ï¼š${characterDisplayName} é‡åˆ°äº†ç‰¹åˆ¥çš„ç‹€æ³ï¼‰`;
          await setDoc(dailyEventDocRef, { triggered: true, character: characterId, timestamp: date.toISOString() });
        }
      } catch (error) {
        console.error("Error checking daily event:", error);
        if (error.code === 'unavailable' || error.message.includes('offline')) {
            window.showModal("åµæ¸¬åˆ°ç¶²è·¯é€£ç·šå•é¡Œï¼Œç„¡æ³•æª¢æŸ¥æ¯æ—¥äº‹ä»¶ã€‚éŠæˆ²å°‡åœ¨é›¢ç·šæ¨¡å¼ä¸‹é‹è¡Œï¼Œç›´åˆ°é€£ç·šæ¢å¾©ã€‚");
        }
      }

      try {
        // Fetch last N messages for conversation history for the specific character
        const chatHistoryCollectionRef = collection(db, 'artifacts', appId, 'users', currentUserId, 'gameData', characterId, 'chatHistory');
        const q = query(chatHistoryCollectionRef, orderBy('timestamp', 'desc'), limit(10)); // Get last 10 messages
        const chatSnapshot = await getDocs(q); // getDocs is now correctly imported and accessible
        const historyMessages = [];
        chatSnapshot.forEach(doc => {
            historyMessages.unshift(doc.data()); // Add to beginning to maintain chronological order
        });

        // Construct payload for Gemini API
        const contents = [];
        // Add historical messages
        historyMessages.forEach(msg => {
            contents.push({ role: msg.role === 'user' ? 'user' : 'model', parts: [{ text: msg.content }] });
        });

        // Add the current user message with system instructions
        const fullPrompt = `ä½ æ˜¯æˆ€æ„›è‚²æˆéŠæˆ²çš„è§’è‰²ã€Œ${characterDisplayName}ã€ï¼Œä½¿ç”¨${language}èˆ‡ç©å®¶å°è©±ã€‚ä»Šæ—¥äº‹ä»¶ï¼š${dailyEvent}ã€‚å¥½æ„Ÿåº¦ï¼š${affection}ï¼Œç­‰ç´šï¼š${level}ã€‚ä½ æ ¹æ“šå¥½æ„Ÿåº¦æ”¹è®Šæ€§æ ¼ä¸¦å¯èƒ½è§¸ç™¼çµå±€ã€‚ç©å®¶èªªï¼šã€Œ${message}ã€`;
        contents.push({ role: "user", parts: [{ text: fullPrompt }] });

        const payload = { contents: contents };
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Gemini API Error: ${response.status} - ${response.statusText}`, errorText);
            throw new Error(`Gemini API request failed: ${response.status} ${response.statusText}. Response: ${errorText}`);
        }

        const data = await response.json();
        const reply = data.candidates && data.candidates.length > 0 &&
                      data.candidates[0].content && data.candidates[0].content.parts &&
                      data.candidates[0].content.parts.length > 0
                      ? data.candidates[0].content.parts[0].text
                      : "æŠ±æ­‰ï¼Œæˆ‘ç¾åœ¨ç„¡æ³•å›æ‡‰ã€‚";

        displayMessage(reply, "ai", characterDisplayName);

        // Save game state to Firestore using character-specific document
        const gameDataDocRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'gameData', characterId);
        await setDoc(gameDataDocRef, {
          affection,
          level,
          character: characterId,
          unlockedAchievements
        }, { merge: true });

        // Save chat history to Firestore for the specific character
        await addDoc(collection(db, 'artifacts', appId, 'users', currentUserId, 'gameData', characterId, 'chatHistory'), {
          role: "user",
          content: message,
          timestamp: Date.now()
        });
        await addDoc(collection(db, 'artifacts', appId, 'users', currentUserId, 'gameData', characterId, 'chatHistory'), {
          role: "ai",
          content: reply,
          timestamp: Date.now()
        });

      } catch (error) {
        console.error("Error sending message or getting AI response:", error);
        displayMessage("ç³»çµ±ï¼šç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚", "ai");
        window.showModal("ç™¼é€è¨Šæ¯æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚éŒ¯èª¤è©³æƒ…ï¼š" + error.message);
      } finally {
        sendButton.disabled = false;
        userInput.disabled = false;
        loadingIndicator.classList.add('hidden');
      }
    }

    // --- Save Game to Firestore ---
    async function saveGame() { // Defined as a regular function within module scope
      if (!currentUserId) {
        window.showModal("è«‹å…ˆç™»å…¥æˆ–ç­‰å¾…åˆå§‹åŒ–å®Œæˆæ‰èƒ½å­˜æª”ã€‚");
        return;
      }
      try {
        const gameDataDocRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'gameData', charSelect.value);
        await setDoc(gameDataDocRef, {
          affection,
          level,
          character: charSelect.value,
          achievements: unlockedAchievements,
          timestamp: Date.now()
        }, { merge: true });
        window.showModal("éŠæˆ²å·²å„²å­˜ï¼");
      } catch (error) {
        console.error("Error saving game:", error);
        if (error.code === 'unavailable' || error.message.includes('offline')) {
            window.showModal("å­˜æª”å¤±æ•—ï¼šç¶²è·¯é€£ç·šå•é¡Œã€‚è«‹æª¢æŸ¥æ‚¨çš„ç¶²è·¯ã€‚");
        } else {
            window.showModal("å­˜æª”å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚éŒ¯èª¤è©³æƒ…ï¼š" + error.message);
        }
      }
    }

    // --- Load Game from Firestore ---
    async function loadGame() { // Defined as a regular function within module scope
      if (!currentUserId) {
        window.showModal("è«‹å…ˆç™»å…¥æˆ–ç­‰å¾…åˆå§‹åŒ–å®Œæˆæ‰èƒ½è¼‰å…¥å­˜æª”ã€‚");
        return;
      }
      const characterId = charSelect.value;
      try {
        const docRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'gameData', characterId);
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
          const data = docSnap.data();
          affection = data.affection || 0;
          level = data.level || 1;
          unlockedAchievements = data.achievements || [];
          charSelect.value = data.character || "yuki"; // Ensure character select matches loaded data
          affectionDisplay.textContent = affection;
          levelDisplay.textContent = level;
          achievementsList.innerHTML = "";
          unlockedAchievements.forEach(title => addAchievement(title));
          updateCharacterImage(charSelect.value);
          window.showModal("å­˜æª”è¼‰å…¥æˆåŠŸï¼");
        } else {
          window.showModal("æ²’æœ‰æ‰¾åˆ°æ­¤è§’è‰²çš„å­˜æª”ï¼Œå°‡é–‹å§‹æ–°éŠæˆ²ã€‚");
          affection = 0;
          level = 1;
          unlockedAchievements = [];
          // charSelect.value remains as selected by user
          affectionDisplay.textContent = affection;
          levelDisplay.textContent = level;
          achievementsList.innerHTML = "";
          updateCharacterImage(charSelect.value);
          const gameDataDocRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'gameData', characterId);
          await setDoc(gameDataDocRef, {
            affection,
            level,
            character: characterId,
            achievements: unlockedAchievements,
            timestamp: Date.now()
          });
        }
        // After loading game data, set up the chat history listener for this character
        setupChatHistoryListener(currentUserId, characterId);

      } catch (error) {
        console.error("Error loading game:", error);
        if (error.code === 'unavailable' || error.message.includes('offline')) {
            window.showModal("è¼‰å…¥å­˜æª”å¤±æ•—ï¼šç¶²è·¯é€£ç·šå•é¡Œã€‚è«‹æª¢æŸ¥æ‚¨çš„ç¶²è·¯ã€‚");
        } else {
            window.showModal("è¼‰å…¥å­˜æª”å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚éŒ¯èª¤è©³æƒ…ï¼š" + error.message);
        }
      }
    }

    // --- Update Character Image ---
    function updateCharacterImage(characterId) {
      characterImage.src = characterDetails[characterId]?.image || characterImages['yuki'];
    }

    // --- Setup Chat History Listener ---
    function setupChatHistoryListener(userId, characterId) {
      // Unsubscribe from previous listener if it exists
      if (unsubscribeChatListener) {
        unsubscribeChatListener();
        unsubscribeChatListener = null;
      }

      if (!userId || !characterId) {
        console.warn("Cannot set up chat history listener: userId or characterId is missing.");
        return;
      }

      // Corrected collection path for character-specific chat history
      const chatHistoryCollectionRef = collection(db, 'artifacts', appId, 'users', userId, 'gameData', characterId, 'chatHistory');
      
      // Using onSnapshot without orderBy due to potential index issues, sorting in memory
      unsubscribeChatListener = onSnapshot(chatHistoryCollectionRef, (snapshot) => {
        chatBox.innerHTML = ""; // Clear chatbox to redraw all messages
        const messages = [];
        snapshot.forEach(doc => {
          messages.push(doc.data());
        });
        // Sort messages by timestamp in memory
        messages.sort((a, b) => a.timestamp - b.timestamp);
        messages.forEach(msg => {
          const characterDisplayName = characterDetails[charSelect.value]?.name || charSelect.value;
          displayMessage(msg.content, msg.role, characterDisplayName);
        });
      }, (error) => {
        console.error("Error listening to chat history:", error);
        if (error.code === 'unavailable' || error.message.includes('offline')) {
            window.showModal("ç„¡æ³•è¼‰å…¥èŠå¤©è¨˜éŒ„ï¼šç¶²è·¯é€£ç·šå•é¡Œã€‚éŠæˆ²å°‡åœ¨é›¢ç·šæ¨¡å¼ä¸‹é‹è¡Œã€‚");
        } else {
            window.showModal("ç„¡æ³•è¼‰å…¥èŠå¤©è¨˜éŒ„ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šã€‚éŒ¯èª¤è©³æƒ…ï¼š" + error.message);
        }
      });
    }

    // --- Event Listeners ---
    charSelect.addEventListener('change', (event) => {
      updateCharacterImage(event.target.value);
      // When character changes, load the save data for that character and set up new chat listener
      window.loadGame();
    });

    // --- Initialization on Window Load ---
    window.onload = async () => {
      try {
        app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);

        if (initialAuthToken) {
          await signInWithCustomToken(auth, initialAuthToken);
        } else {
          await signInAnonymously(auth);
        }

        onAuthStateChanged(auth, (user) => {
          if (user) {
            currentUserId = user.uid;
            playerUserIdDisplay.textContent = currentUserId;
            console.log("User authenticated:", currentUserId);

            // Initial load for the currently selected character
            window.loadGame();

          } else {
            currentUserId = null;
            playerUserIdDisplay.textContent = "æœªç™»å…¥";
            console.log("No user is signed in.");
            window.showModal("ç„¡æ³•ç™»å…¥ä½¿ç”¨è€…ï¼ŒéŠæˆ²åŠŸèƒ½å¯èƒ½å—é™ã€‚");
          }
        });

      } catch (error) {
        console.error("Firebase initialization or authentication failed:", error);
        window.showModal("éŠæˆ²åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ§åˆ¶å°éŒ¯èª¤è¨Šæ¯ã€‚éŒ¯èª¤è©³æƒ…ï¼š" + error.message);
      }

      updateCharacterImage(charSelect.value);
    };

    // Expose functions to the global scope for HTML onclick attributes
    window.sendMessage = sendMessage;
    window.saveGame = saveGame;
    window.loadGame = loadGame;
    window.setupChatHistoryListener = setupChatHistoryListener; // Not strictly necessary for global access but good for consistency
  </script>
</body>
</html>
